# 现有高亮插件代码问题分析

## 🔴 核心问题总结

你的代码主要有 **5 个关键性错误**，导致无法正确实现高亮功能。

---

## 问题 1: ❌ 使用了错误的 API

### 你的代码 (toolbarHijacker.ts:36-42)
```typescript
this.api = {
    updateBlock: async (blockId: string, data: string, dataType: string) => {
        const response = await fetch('/api/block/updateBlock', {  // ❌ 错误的API
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                id: blockId,
                data: data,
                dataType: dataType  // ❌ 错误的参数格式
            })
        });
        return await response.json();
    }
}
```

### 思源原生方式
```typescript
// 正确：使用 /api/transactions
fetchPost("/api/transactions", {
    session: protyle.id,
    app: "siyuan",
    transactions: [{
        doOperations: [{
            action: "update",
            id: blockId,
            data: newHTML  // 完整的块 HTML
        }],
        undoOperations: [{
            action: "update",
            id: blockId,
            data: oldHTML  // 旧的块 HTML
        }]
    }]
});
```

### 为什么错误？
- `/api/block/updateBlock` 是**旧版 API**，不支持完整的事务管理
- 缺少 **undoOperations**（撤销操作），无法支持 Ctrl+Z
- 思源内部索引机制依赖 `/api/transactions` 来更新 spans 和 attributes 表
- `dataType: "markdown"` 参数不正确，应该传递完整的 HTML 块内容

---

## 问题 2: ❌ 手动创建 span 元素的方式不对

### 你的代码 (toolbarHijacker.ts:873-880)
```typescript
// ❌ 错误：手动创建 span
const highlightSpan = document.createElement("span");
highlightSpan.setAttribute("data-type", "text");
highlightSpan.style.backgroundColor = colorConfig.color;
highlightSpan.textContent = selectedText;

// ❌ 错误：直接DOM操作
range.deleteContents();
range.insertNode(highlightSpan);
```

### 思源原生方式 (app/src/protyle/toolbar/index.ts:519-530)
```typescript
// ✅ 正确：使用 setInlineMark + setFontStyle
contents.childNodes.forEach((item: HTMLElement) => {
    if (item.nodeType === 3 && item.textContent) {
        const inlineElement = document.createElement("span");
        inlineElement.setAttribute("data-type", type);  // "text"
        inlineElement.textContent = item.textContent;
        
        // 关键：使用 setFontStyle 设置样式
        setFontStyle(inlineElement, textObj);
        // 这会处理：
        // - backgroundColor 设置
        // - 相邻 span 合并
        // - IAL 属性生成
        
        newNodes.push(inlineElement);
    }
});
```

### 为什么错误？
- 你没有调用 **思源的 setInlineMark 方法**
- 缺少 **IAL (Inline Attribute List)** 的生成
- 没有处理**相邻 span 合并**的逻辑
- 不符合思源的 **Kramdown 格式要求**

---

## 问题 3: ❌ 保存的数据格式完全错误

### 你的代码 (toolbarHijacker.ts:888-899)
```typescript
// ❌ 错误：保存 innerHTML 而不是完整的块 HTML
const newContent = blockElement.innerHTML;  // 只有内容，没有块级属性

// ❌ 错误：然后又尝试提取 markdown
const markdownContent = await this.extractMarkdownFromBlock(blockElement);

// ❌ 错误：使用错误的 API 和格式
const updateResult = await this.api.updateBlock(blockId, markdownContent, "markdown");
```

### 思源原生方式 (app/src/protyle/wysiwyg/transaction.ts:1436-1448)
```typescript
// ✅ 正确：保存完整的块 outerHTML
export const updateTransaction = (protyle: IProtyle, id: string, 
                                  newHTML: string, html: string) => {
    if (newHTML === html) return;
    
    transaction(protyle, [{
        id,              // 块 ID
        data: newHTML,   // ✅ 新的完整块 outerHTML（包含 <div data-node-id="...">...</div>）
        action: "update"
    }], [{
        id,
        data: html,      // ✅ 旧的完整块 outerHTML
        action: "update"
    }]);
};
```

### 思源需要的完整 HTML 格式
```html
<div 
    data-node-id="20251001111753-36y1un2" 
    data-type="NodeParagraph" 
    class="p" 
    updated="20251001111824"
>
    <div contenteditable="true" spellcheck="false">
        关键信息是<span data-type="text" style="background-color: var(--b3-font-background2);">我爱</span>你
    </div>
    <div class="protyle-attr" contenteditable="false">​</div>
</div>
```

### 为什么错误？
- 你只保存了 `innerHTML`（内容），但思源需要 `outerHTML`（包含块属性的完整 HTML）
- 缺少必须的属性：`data-node-id`、`data-type`、`class`、`updated`
- 缺少 `<div class="protyle-attr">` 属性区域
- 你尝试提取 markdown，但思源的 transactions API **不接受 markdown**，只接受 HTML

---

## 问题 4: ❌ 没有使用思源的工具栏 API

### 你的代码 (toolbarHijacker.ts:129-143)
```typescript
// ❌ 错误：劫持 showContent 后自己重新实现高亮逻辑
editor.protyle.toolbar.showContent = function(protyle: any, range: Range, nodeElement: Element) {
    hijacker.originalShowContent.call(this, protyle, range, nodeElement);
    
    setTimeout(() => {
        hijacker.enhanceToolbar(this, range, nodeElement, protyle);  // ❌ 自己实现
    }, 50);
};
```

### 思源原生方式 (app/src/protyle/toolbar/Font.ts:228-287)
```typescript
// ✅ 正确：调用思源的 setInlineMark
export const fontEvent = (protyle: IProtyle, nodeElements: Element[], type?: string, color?: string) => {
    if (nodeElements && nodeElements.length > 0) {
        // 批量修改已选中的块
        updateBatchTransaction(nodeElements, protyle, (e: HTMLElement) => {
            if (type === "backgroundColor") {
                e.style.backgroundColor = color;
            }
        });
    } else {
        // ✅ 关键：调用 setInlineMark 添加高亮
        protyle.toolbar.setInlineMark(protyle, "text", "range", {type, color});
    }
};
```

### 为什么错误？
- 你没有调用 `protyle.toolbar.setInlineMark`
- 自己手动实现的逻辑缺少很多边界处理：
  - 跨 span 选择的合并
  - 零宽字符（ZWSP）的处理
  - 表格、代码块等特殊场景
  - Range 边界的调整

---

## 问题 5: ❌ 缺少 undoOperations（撤销操作）

### 你的代码
```typescript
// ❌ 完全没有 undoOperations 的概念
const updateResult = await this.api.updateBlock(blockId, newContent, "markdown");
```

### 思源原生方式
```typescript
// ✅ 每次修改都需要同时提供 do 和 undo 操作
transaction(protyle, 
    // doOperations - 要执行的操作
    [{
        id: blockId,
        data: newHTML,
        action: "update"
    }], 
    // undoOperations - 撤销操作（Ctrl+Z 用）
    [{
        id: blockId,
        data: oldHTML,
        action: "update"
    }]
);
```

### 为什么重要？
- 用户按 `Ctrl+Z` 时无法撤销
- 思源的**协同编辑**依赖 undoOperations
- **历史记录**功能需要完整的操作记录

---

## 🔧 正确的实现方式

### 方案 A: 完全复用思源原生方法（推荐）

```typescript
// 1. 劫持工具栏，但调用原生 API
private enhanceToolbar(toolbar: any, range: Range, nodeElement: Element, protyle: any): void {
    // 添加你的自定义按钮
    const btn = document.createElement('button');
    btn.onclick = () => {
        // ✅ 调用思源原生的 fontEvent
        const color = '#fff3cd';  // 你的自定义颜色
        
        // 关键：调用思源的 API
        protyle.toolbar.setInlineMark(protyle, "text", "range", {
            type: "backgroundColor",
            color: color
        });
    };
}
```

### 方案 B: 使用 transactions API（如果必须自定义）

```typescript
private async applyHighlight(protyle: any, range: Range, nodeElement: Element, color: string): Promise<void> {
    const blockElement = hasClosestBlock(range.startContainer);
    const blockId = blockElement.getAttribute("data-node-id");
    
    // 1. 保存旧的完整 HTML
    const oldHTML = blockElement.outerHTML;  // ✅ outerHTML，不是 innerHTML
    
    // 2. 使用思源的 setInlineMark 创建 span
    const span = document.createElement("span");
    span.setAttribute("data-type", "text");
    span.style.backgroundColor = color;
    span.textContent = range.toString();
    
    range.deleteContents();
    range.insertNode(span);
    
    // 3. 获取新的完整 HTML
    const newHTML = blockElement.outerHTML;  // ✅ outerHTML
    
    // 4. 使用 transactions API 保存
    await fetchPost("/api/transactions", {
        session: protyle.id,
        app: "siyuan",
        transactions: [{
            doOperations: [{
                action: "update",
                id: blockId,
                data: newHTML  // ✅ 完整的块 HTML
            }],
            undoOperations: [{
                action: "update",
                id: blockId,
                data: oldHTML  // ✅ 旧的完整块 HTML
            }]
        }]
    });
}
```

---

## 🚫 你不应该做的事情

### ❌ 不要自己解析/生成 Markdown
```typescript
// ❌ 错误
const markdownContent = await this.extractMarkdownFromBlock(blockElement);
const processedHtml = this.convertHighlightSpansToMarkdown(modifiedHtml);
```
**原因**：思源会自动处理 HTML → Markdown 的转换

### ❌ 不要使用 getBlockKramdown
```typescript
// ❌ 错误
const response = await this.api.getBlockKramdown(blockId);
```
**原因**：你不需要获取 Kramdown，直接操作 DOM 然后提交 outerHTML 即可

### ❌ 不要手动处理 IAL
```typescript
// ❌ 错误
const processedInnerHTML = this.processLinkWithHighlights(span);
```
**原因**：思源的后端会自动解析 HTML 生成 IAL

### ❌ 不要保存 innerHTML
```typescript
// ❌ 错误
const newContent = blockElement.innerHTML;
```
**原因**：必须使用 `outerHTML` 包含完整的块结构

---

## ✅ 推荐的修改步骤

### 步骤 1: 删除错误的 API 封装
```typescript
// 删除 toolbarHijacker.ts 的 28-57 行
// 不需要自己封装 updateBlock 和 getBlockKramdown
```

### 步骤 2: 使用 siyuan 包的 fetchPost
```typescript
import { fetchPost } from "siyuan";

// 使用官方的 fetchPost 调用 transactions API
await fetchPost("/api/transactions", { ... });
```

### 步骤 3: 简化 applyHighlight 方法
```typescript
private async applyHighlight(protyle: any, range: Range, color: string): Promise<void> {
    // 直接调用思源的 setInlineMark
    protyle.toolbar.setInlineMark(protyle, "text", "range", {
        type: "backgroundColor",
        color: color
    });
}
```

### 步骤 4: 删除所有 Markdown 相关代码
```typescript
// 删除以下方法（845-1381 行）：
// - extractMarkdownFromBlock
// - mergeHighlightIntoMarkdown
// - convertHighlightSpansToMarkdown
// - processLinkWithHighlights

// 原因：思源会自动处理，不需要手动转换
```

### 步骤 5: 修复事务提交
```typescript
// 如果必须自定义实现，使用正确的格式
const blockElement = hasClosestBlock(range.startContainer);
const oldHTML = blockElement.outerHTML;  // ✅

// ... DOM 操作 ...

const newHTML = blockElement.outerHTML;  // ✅

await fetchPost("/api/transactions", {
    session: protyle.id,
    app: "siyuan",
    transactions: [{
        doOperations: [{ action: "update", id: blockId, data: newHTML }],
        undoOperations: [{ action: "update", id: blockId, data: oldHTML }]
    }]
});
```

---

## 📊 问题影响等级

| 问题 | 严重程度 | 影响 | 修复优先级 |
|------|---------|------|-----------|
| 使用错误的 API | 🔴 致命 | 数据无法正确索引到 spans/attributes 表 | P0 |
| 手动创建 span 不符合规范 | 🔴 致命 | 缺少 IAL，无法被思源正确识别 | P0 |
| 保存格式错误 | 🔴 致命 | 块结构不完整，导致数据损坏 | P0 |
| 没有使用 setInlineMark | 🟠 严重 | 缺少边界处理，易出 bug | P1 |
| 缺少 undoOperations | 🟡 中等 | 无法撤销，用户体验差 | P2 |

---

## 🎯 最简单的修复方案

**直接调用思源原生方法，不要重新实现！**

```typescript
// toolbarHijacker.ts - 简化版
private createHighlightButton(colorConfig: any, range: Range, protyle: any): HTMLButtonElement {
    const btn = document.createElement('button');
    btn.style.cssText = `background: ${colorConfig.bg} !important; ...`;
    
    btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        
        // ✅ 核心：直接调用思源原生 API
        protyle.toolbar.setInlineMark(protyle, "text", "range", {
            type: "backgroundColor",
            color: colorConfig.bg
        });
        
        // 完成！思源会自动：
        // 1. 创建符合规范的 span
        // 2. 生成 IAL
        // 3. 调用 /api/transactions
        // 4. 更新数据库（blocks、spans、attributes）
        // 5. 支持撤销（undoOperations）
    });
    
    return btn;
}
```

这样修改后，你的代码量可以**减少 80%**，而且更加稳定可靠！

