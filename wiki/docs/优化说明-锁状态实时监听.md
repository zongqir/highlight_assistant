# 优化说明 - 锁状态实时监听

**日期**: 2025-10-02  
**版本**: v1.2.1  
**类型**: 功能增强 / 响应式优化

## 🎯 优化目标

实现**前端强相关的响应式状态监听**：当用户点击锁按钮切换状态时，插件立即感知并作出响应。

## 💡 用户需求（原话）

> "我觉得触发这块的逻辑 你得挪列一下 我发现 这个和前段强相关 **只要我点击了锁的切换 你就得无脑获取一次最新的**"

## 🔍 问题分析

### 之前的逻辑（被动检查）

```
用户点击锁按钮 🔒 → 思源切换状态
                    ↓
                  （无感知）
                    ↓
用户选中文本 → 此时才检查状态 ✅
```

**问题**：
- ❌ 只在选中文本时检查，不是实时的
- ❌ 锁状态改变后，如果工具栏已显示，不会自动隐藏
- ❌ 需要用户重新操作才能看到状态变化的效果

### 现在的逻辑（主动监听 + 响应式）

```
用户点击锁按钮 🔒 → 思源切换状态
                    ↓
              监听器立即捕获 🔔
                    ↓
         立即获取最新状态 ⚡
                    ↓
    通知所有订阅者（如工具栏管理器）
                    ↓
        自动隐藏工具栏（如果解锁）✅
```

**优势**：
- ✅ 点击后立即感知，无需等待
- ✅ 自动触发UI响应（隐藏工具栏等）
- ✅ 响应式设计，状态与UI自动同步

## 📦 新增文件

### `src/utils/readonlyStateMonitor.ts`

**只读状态监听器** - 单例模式的状态监听管理器

#### 核心功能

1. **双重监听机制**
   - 🥇 **事件代理监听** - 捕获锁按钮的点击事件（快速响应）
   - 🥈 **MutationObserver** - 监听DOM属性变化（兜底方案）

2. **发布-订阅模式**
   - 提供 `subscribe()` 方法让组件订阅状态变化
   - 状态改变时自动通知所有订阅者
   - 返回取消订阅函数，便于清理

3. **状态缓存**
   - 缓存当前状态，避免重复查询
   - 只有状态真正改变时才通知订阅者

#### API接口

```typescript
class ReadonlyStateMonitor {
    // 启动监听
    startMonitoring(): void;
    
    // 停止监听
    stopMonitoring(): void;
    
    // 订阅状态变化（返回取消订阅函数）
    subscribe(callback: (isReadonly: boolean) => void): () => void;
    
    // 手动触发状态更新
    forceUpdate(): void;
    
    // 获取当前缓存的状态
    getCurrentState(): boolean | null;
}
```

## 🔧 修改文件

### 1. `src/utils/customToolbarManager.ts`

#### 新增功能

**自动响应状态变化**：
- 在构造函数中订阅只读状态变化
- 当状态从只读变为可编辑时，自动隐藏工具栏
- 在 cleanup 中取消订阅，避免内存泄漏

```typescript
export class CustomToolbarManager {
    private unsubscribeStateMonitor: (() => void) | null = null;
    
    constructor(...) {
        // ...
        this.subscribeToReadonlyState();
    }
    
    private subscribeToReadonlyState(): void {
        this.unsubscribeStateMonitor = readonlyStateMonitor.subscribe((isReadonly: boolean) => {
            // 如果状态变为可编辑（解锁），立即隐藏工具栏
            if (!isReadonly) {
                Logger.log('⚡ 文档已解锁，立即隐藏自定义工具栏');
                this.hideCustomToolbar();
            }
        });
    }
    
    cleanup(): void {
        // 取消订阅
        if (this.unsubscribeStateMonitor) {
            this.unsubscribeStateMonitor();
            this.unsubscribeStateMonitor = null;
        }
        // ...
    }
}
```

### 2. `src/index.ts`

#### 启动和停止监听器

**在插件生命周期中管理监听器**：

```typescript
import { readonlyStateMonitor } from "./utils/readonlyStateMonitor";

onLayoutReady() {
    // 🔔 启动只读状态监听器（在编辑器完全加载后）
    setTimeout(() => {
        Logger.log('[Plugin] 🔔 启动只读状态监听器...');
        readonlyStateMonitor.startMonitoring();
    }, 500);
    // ...
}

async onunload() {
    // 停止只读状态监听器
    Logger.log('[Plugin] 🔔 停止只读状态监听器...');
    readonlyStateMonitor.stopMonitoring();
    // ...
}
```

## 🔄 工作流程

### 完整的状态变化流程

```
1. 用户点击锁按钮 🔒
   ↓
2. 事件代理捕获点击事件
   📡 [StateMonitor] 检测到锁按钮点击
   ↓
3. 延迟150ms后获取新状态（让思源的处理先完成）
   ↓
4. 调用 getCurrentActiveReadonlyButton() 获取当前tab的锁按钮
   ↓
5. 调用 isCurrentDocumentReadonly() 判断状态
   ↓
6. 比较新旧状态
   🔄 [StateMonitor] 状态变化: 🔒 只读 → ✏️ 可编辑
   ↓
7. 通知所有订阅者
   📢 [StateMonitor] 通知 N 个订阅者...
   ↓
8. CustomToolbarManager 收到通知
   🔔 [CustomToolbar] 收到状态变化通知: ✏️ 可编辑
   ↓
9. 立即执行响应动作
   ⚡ [CustomToolbar] 文档已解锁，立即隐藏自定义工具栏
```

### 兜底机制（MutationObserver）

如果点击事件没捕获到（被其他代码阻止等），MutationObserver会检测到DOM属性变化：

```
1. 锁按钮的属性改变（aria-label、data-subtype等）
   ↓
2. MutationObserver 触发回调
   🔔 [StateMonitor] 检测到锁按钮DOM属性变化
   ↓
3. 延迟100ms后获取新状态
   ↓
4-9. 同上
```

## 📊 性能优化

### 1. 状态缓存
```typescript
private currentState: boolean | null = null;

private updateState(): void {
    const newState = isCurrentDocumentReadonly();
    
    // 只有状态真正改变时才通知
    if (newState !== this.currentState) {
        this.currentState = newState;
        this.notifySubscribers(newState);
    } else {
        Logger.log('状态未变化，保持:', newState ? '🔒 只读' : '✏️ 可编辑');
    }
}
```

### 2. 延迟获取状态
```typescript
// 点击事件后延迟150ms，让思源的处理先完成
setTimeout(() => {
    this.updateState();
}, 150);
```

### 3. 事件代理
```typescript
// 使用捕获阶段，确保能第一时间捕获到事件
document.addEventListener('click', this.clickListener, true);
```

## 🎨 日志示例

### 启动监听
```
[Plugin] 🔔 启动只读状态监听器...
📡 [StateMonitor] 启动只读状态监听...
📡 [StateMonitor] 状态变化: { 旧状态: '未知', 新状态: '🔒 只读', 订阅者数量: 1 }
📢 [StateMonitor] 通知 1 个订阅者...
🔔 [CustomToolbar] 收到状态变化通知: 🔒 只读
✅ [StateMonitor] 监听已启动
```

### 点击锁按钮（锁定 → 解锁）
```
🔔 [StateMonitor] 检测到锁按钮点击
🔍 [ReadonlyButton] 开始查找当前活跃文档的锁按钮...
✅ [ReadonlyButton] 策略2成功 - 通过焦点元素找到锁按钮
🔐 [ReadonlyButton] 当前文档状态: { 图标href: '#iconUnlock', 是否只读: '✏️ 否（解锁）' }
🔄 [StateMonitor] 状态变化: { 旧状态: '🔒 只读', 新状态: '✏️ 可编辑', 订阅者数量: 1 }
📢 [StateMonitor] 通知 1 个订阅者...
🔔 [CustomToolbar] 收到状态变化通知: ✏️ 可编辑
⚡ [CustomToolbar] 文档已解锁，立即隐藏自定义工具栏
```

### 点击锁按钮（解锁 → 锁定）
```
🔔 [StateMonitor] 检测到锁按钮点击
🔍 [ReadonlyButton] 开始查找当前活跃文档的锁按钮...
✅ [ReadonlyButton] 策略1成功 - 通过getActiveTab找到锁按钮
🔐 [ReadonlyButton] 当前文档状态: { 图标href: '#iconLock', 是否只读: '🔒 是（锁定）' }
🔄 [StateMonitor] 状态变化: { 旧状态: '✏️ 可编辑', 新状态: '🔒 只读', 订阅者数量: 1 }
📢 [StateMonitor] 通知 1 个订阅者...
🔔 [CustomToolbar] 收到状态变化通知: 🔒 只读
```

### 停止监听
```
[Plugin] 🔔 停止只读状态监听器...
📡 [StateMonitor] 停止监听...
✅ [StateMonitor] 监听已停止
```

## 🎯 解决的问题

| 问题 | 之前 | 现在 |
|------|------|------|
| **响应速度** | ❌ 需要重新操作才感知 | ✅ 点击后立即感知 |
| **UI同步** | ❌ 手动检查 | ✅ 自动同步 |
| **工具栏状态** | ❌ 解锁后仍显示 | ✅ 解锁后立即隐藏 |
| **架构设计** | ❌ 被动检查 | ✅ 响应式监听 |
| **用户体验** | ⚠️ 有延迟感 | ✅ 即时响应 |

## 🎨 设计模式

### 1. 单例模式
```typescript
export class ReadonlyStateMonitor {
    private static instance: ReadonlyStateMonitor;
    
    public static getInstance(): ReadonlyStateMonitor {
        if (!ReadonlyStateMonitor.instance) {
            ReadonlyStateMonitor.instance = new ReadonlyStateMonitor();
        }
        return ReadonlyStateMonitor.instance;
    }
}
```

### 2. 发布-订阅模式
```typescript
private callbacks: Set<ReadonlyStateChangeCallback> = new Set();

public subscribe(callback: ReadonlyStateChangeCallback): () => void {
    this.callbacks.add(callback);
    
    // 返回取消订阅的函数
    return () => {
        this.callbacks.delete(callback);
    };
}

private notifySubscribers(isReadonly: boolean): void {
    this.callbacks.forEach((callback) => {
        callback(isReadonly);
    });
}
```

### 3. 观察者模式
```typescript
// MutationObserver 监听DOM变化
this.mutationObserver = new MutationObserver((mutations) => {
    // 检测到属性变化时触发
    this.updateState();
});
```

## 🚀 扩展性

### 轻松添加新的订阅者

如果以后其他模块也需要监听锁状态变化：

```typescript
import { readonlyStateMonitor } from './utils/readonlyStateMonitor';

class SomeOtherManager {
    private unsubscribe: (() => void) | null = null;
    
    init() {
        // 订阅状态变化
        this.unsubscribe = readonlyStateMonitor.subscribe((isReadonly) => {
            // 你的响应逻辑
            if (isReadonly) {
                // 锁定时的处理
            } else {
                // 解锁时的处理
            }
        });
    }
    
    cleanup() {
        // 取消订阅
        if (this.unsubscribe) {
            this.unsubscribe();
        }
    }
}
```

## 📋 构建信息

```bash
npm run build
✓ 25 modules transformed.
dist/index.js   179.08 kB │ gzip: 47.07 kB
✓ built in 689ms
```

- **新增代码**: ~240行
- **文件大小增加**: ~3 kB (179.08 kB vs 176.07 kB)
- **gzip后增加**: ~0.94 kB (47.07 kB vs 46.13 kB)

## ✅ 测试建议

### 基础测试
1. ✅ 启动插件，检查控制台是否有监听启动日志
2. ✅ 打开文档，锁定状态
3. ✅ 选中文本，工具栏应该显示
4. ✅ **点击锁按钮解锁**，工具栏应该**立即消失**
5. ✅ 再次锁定，选中文本，工具栏应该显示

### 高级测试
1. ✅ 打开多个tab，切换tab后点击锁按钮，验证是否获取正确的tab
2. ✅ 快速连续点击锁按钮，验证是否每次都正确响应
3. ✅ 卸载插件，验证监听器是否正确停止

### 日志验证
在控制台过滤日志：
- 输入 `StateMonitor` - 查看状态监听器日志
- 输入 `CustomToolbar` - 查看工具栏响应日志
- 输入 `ReadonlyButton` - 查看锁按钮查找日志

## 🎯 总结

| 方面 | 说明 |
|------|------|
| **核心改进** | 从"被动检查"升级为"主动监听 + 响应式" |
| **用户价值** | 点击锁按钮后立即响应，无需重新操作 |
| **技术实现** | 双重监听（点击事件 + DOM变化）+ 发布订阅模式 |
| **架构优势** | 解耦状态监听和业务逻辑，易扩展 |
| **性能影响** | 最小化（状态缓存 + 智能去重） |

---

**完成日期**: 2025-10-02  
**构建状态**: ✅ 成功  
**测试状态**: ⏳ 待验证  
**关键特性**: 🔔 响应式状态监听 + ⚡ 即时UI响应

