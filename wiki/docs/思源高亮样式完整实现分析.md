# 思源笔记：高亮样式完整实现分析

## 目录
1. [完整数据流](#完整数据流)
2. [前端行为详解](#前端行为详解)
3. [API 接口详解](#api-接口详解)
4. [后端处理详解](#后端处理详解)
5. [数据库操作详解](#数据库操作详解)
6. [插件开发指南](#插件开发指南)

---

## 完整数据流

```
用户操作
    ↓
┌─────────────────────────── 前端 ──────────────────────────┐
│                                                             │
│ 1. 用户选择文本 "我爱"                                      │
│ 2. 点击工具栏背景色按钮                                     │
│ 3. Font.ts::fontEvent()                                    │
│    - 获取选中的 Range 对象                                  │
│    - 确定块元素 (block_id)                                  │
│    - 统计选区内的元素类型                                   │
│                                                             │
│ 4. Toolbar.ts::setInlineMark()                            │
│    ├─ 创建 <span data-type="text" style="...">我爱</span>  │
│    ├─ 插入到 DOM 中                                         │
│    └─ 合并相邻的相同样式 span                               │
│                                                             │
│ 5. transaction.ts::updateTransaction()                    │
│    ├─ 生成 doOperations (新 HTML)                          │
│    ├─ 生成 undoOperations (旧 HTML)                        │
│    └─ 调用 fetchPost("/api/transactions", {...})          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                           │
                           │ HTTP POST
                           ↓
┌─────────────────────── 后端 API ──────────────────────────┐
│                                                             │
│ 6. api/transaction.go::performTransactions()              │
│    ├─ 接收 transactions 数组                               │
│    ├─ 解析 doOperations                                    │
│    └─ 调用 model.PerformTransactions()                    │
│                                                             │
│ 7. model/transaction.go::PerformTransactions()            │
│    ├─ 遍历每个 operation                                   │
│    ├─ 针对 action: "update"                                │
│    ├─ 解析 HTML → Lute AST                                │
│    └─ 调用 sql.UpsertTree()                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                           │
                           ↓
┌──────────────────────── 数据库层 ─────────────────────────┐
│                                                             │
│ 8. sql/upsert.go::upsertTree()                            │
│    ├─ sql/database.go::fromTree()                         │
│    │   ├─ 遍历 AST 节点                                    │
│    │   ├─ buildSpanFromNode() → spans 数据                │
│    │   ├─ buildAttributeFromNode() → attributes 数据      │
│    │   └─ buildBlockFromNode() → blocks 数据              │
│    │                                                        │
│    ├─ 批量插入数据                                         │
│    │   ├─ INSERT INTO blocks (...)                        │
│    │   ├─ INSERT INTO spans (...)                         │
│    │   └─ INSERT INTO attributes (...)                    │
│    │                                                        │
│    └─ 触发索引更新                                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                           │
                           ↓
                    ┌──────────────┐
                    │   数据库结果  │
                    ├──────────────┤
                    │ blocks: 1条   │
                    │ spans: 1条    │
                    │ attributes: 1条│
                    └──────────────┘
```

---

## 前端行为详解

### 1. 用户选择文本并触发样式

#### 1.1 选择文本 (浏览器 Selection API)

```typescript
// 前端获取选区
const selection = window.getSelection();
const range = selection.getRangeAt(0);

// 示例：选中 "我爱" 两个字
{
  startContainer: TextNode("关键信息是我爱你"),
  startOffset: 5,          // "我" 的位置
  endContainer: TextNode("关键信息是我爱你"),
  endOffset: 7,            // "你" 之前的位置
  commonAncestorContainer: <div data-node-id="20251001111753-36y1un2">
}
```

#### 1.2 点击工具栏按钮 (app/src/protyle/toolbar/Font.ts)

```typescript
// 步骤 1: 打开样式菜单
export class Font extends ToolbarItem {
    constructor(protyle: IProtyle, menuItem: IMenuItem) {
        this.element.addEventListener("click", () => {
            // 显示颜色选择面板
            protyle.toolbar.subElement.append(appearanceMenu(protyle, nodeElements));
        });
    }
}

// 步骤 2: 构建颜色面板
export const appearanceMenu = (protyle: IProtyle, nodeElements?: Element[]) => {
    let bgHTML = "";
    // 预设的 13 种背景色
    ["", "var(--b3-font-background1)", "var(--b3-font-background2)", ...].forEach((item) => {
        bgHTML += `<button class="color__square" 
                          style="background-color:${item}" 
                          data-type="backgroundColor"></button>`;
    });
    
    // 监听点击事件
    element.addEventListener("click", function (event) {
        if (dataType === "backgroundColor") {
            // 调用 fontEvent 应用样式
            fontEvent(protyle, nodeElements, dataType, target.style.backgroundColor);
        }
    });
};

// 步骤 3: 应用样式
export const fontEvent = (protyle: IProtyle, nodeElements: Element[], 
                          type?: string, color?: string) => {
    // 记录最近使用的样式（本地存储）
    window.siyuan.storage[Constants.LOCAL_FONTSTYLES].push(`${type}${Constants.ZWSP}${color}`);
    
    if (nodeElements && nodeElements.length > 0) {
        // 场景 A: 批量修改已选中的块
        updateBatchTransaction(nodeElements, protyle, (e: HTMLElement) => {
            if (type === "backgroundColor") {
                e.style.backgroundColor = color;  // 直接设置 DOM 样式
            }
        });
    } else {
        // 场景 B: 给选中的文本添加样式（你的场景）
        protyle.toolbar.setInlineMark(protyle, "text", "range", {type, color});
    }
};
```

### 2. 创建 Span 元素 (app/src/protyle/toolbar/index.ts)

```typescript
public setInlineMark(protyle: IProtyle, type: string, action: "range" | "toolbar", 
                     textObj?: ITextOption) {
    // 步骤 1: 获取块元素
    const nodeElement = hasClosestBlock(this.range.startContainer);
    const blockId = nodeElement.getAttribute("data-node-id");  // 20251001111753-36y1un2
    
    // 步骤 2: 分析选区内的元素类型
    let rangeTypes: string[] = [];
    this.range.cloneContents().childNodes.forEach((item: HTMLElement) => {
        if (item.nodeType !== 3) {  // 非文本节点
            rangeTypes = rangeTypes.concat(item.getAttribute("data-type").split(" "));
        }
    });
    
    // 步骤 3: 提取选中的内容
    this.range.insertNode(document.createElement("wbr"));  // 插入书签
    const html = nodeElement.outerHTML;  // 保存旧 HTML（用于 undo）
    const contents = this.range.extractContents();  // 提取选中内容
    
    // 步骤 4: 创建新的 span 元素
    contents.childNodes.forEach((item: HTMLElement) => {
        if (item.nodeType === 3 && item.textContent) {  // 文本节点
            const inlineElement = document.createElement("span");
            inlineElement.setAttribute("data-type", type);  // "text"
            inlineElement.textContent = item.textContent;   // "我爱"
            
            // 应用样式 (setFontStyle)
            if (textObj.type === "backgroundColor") {
                inlineElement.style.backgroundColor = textObj.color;
                // 结果: <span data-type="text" style="background-color: var(--b3-font-background2);">我爱</span>
            }
            
            newNodes.push(inlineElement);
        }
    });
    
    // 步骤 5: 插入新元素
    newNodes.forEach(item => this.range.insertNode(item));
    
    // 步骤 6: 提交事务
    updateTransaction(protyle, blockId, nodeElement.outerHTML, html);
}
```

### 3. 提交事务 (app/src/protyle/wysiwyg/transaction.ts)

```typescript
export const updateTransaction = (protyle: IProtyle, id: string, 
                                  newHTML: string, html: string) => {
    if (newHTML === html) return;  // 无变化则跳过
    
    transaction(protyle, [{
        id,              // "20251001111753-36y1un2"
        data: newHTML,   // 新的 HTML（包含 span）
        action: "update"
    }], [{
        id,
        data: html,      // 旧的 HTML（用于撤销）
        action: "update"
    }]);
};

// 实际发送请求
const promiseTransaction = () => {
    const doOperations = window.siyuan.transactions[0].doOperations;
    const undoOperations = window.siyuan.transactions[0].undoOperations;
    
    fetchPost("/api/transactions", {
        session: protyle.id,           // 编辑器会话 ID
        app: Constants.SIYUAN_APPID,   // "siyuan"
        transactions: [{
            doOperations,      // 要执行的操作
            undoOperations     // 撤销操作
        }]
    }, (response) => {
        // 处理响应，更新嵌入块等
    });
};
```

### 4. 前端关键数据结构

```typescript
// 发送到后端的数据格式
{
  "session": "sy-20250101-editor-1",
  "app": "siyuan",
  "transactions": [{
    "doOperations": [{
      "action": "update",
      "id": "20251001111753-36y1un2",
      "data": "<div data-node-id=\"20251001111753-36y1un2\" ...>关键信息是<span data-type=\"text\" style=\"background-color: var(--b3-font-background2);\">我爱</span>你</div>"
    }],
    "undoOperations": [{
      "action": "update",
      "id": "20251001111753-36y1un2",
      "data": "<div data-node-id=\"20251001111753-36y1un2\" ...>关键信息是我爱你</div>"
    }]
  }]
}
```

---

## API 接口详解

### POST /api/transactions

#### 请求参数

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| `session` | string | 是 | 编辑器会话 ID，用于区分不同的编辑器实例 |
| `app` | string | 是 | 应用标识，固定为 "siyuan" |
| `transactions` | array | 是 | 事务数组，每个事务包含 doOperations 和 undoOperations |

#### transactions[].doOperations 字段

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `action` | string | 操作类型：`update`, `insert`, `delete`, `move`, `foldHeading`, `unfoldHeading` |
| `id` | string | 块 ID（20位雪花ID） |
| `data` | string | 新的 HTML 内容（action=update/insert 时需要） |
| `parentID` | string | 父块 ID（action=insert 时需要） |
| `previousID` | string | 前一个兄弟块 ID（action=move 时需要） |

#### 响应数据

```json
{
  "code": 0,
  "msg": "",
  "data": [{
    "doOperations": [{
      "action": "update",
      "id": "20251001111753-36y1un2",
      "data": "<div ...>...</div>",
      "retData": null
    }],
    "undoOperations": [...]
  }]
}
```

---

## 后端处理详解

### 1. API 入口 (kernel/api/transaction.go)

```go
func performTransactions(c *gin.Context) {
    // 解析请求
    var request struct {
        Session      string        `json:"session"`
        App          string        `json:"app"`
        Transactions []Transaction `json:"transactions"`
    }
    c.BindJSON(&request)
    
    // 调用模型层
    result := model.PerformTransactions(&request)
    
    c.JSON(200, result)
}
```

### 2. 事务处理 (kernel/model/transaction.go)

```go
func PerformTransactions(req *TransactionsRequest) (result) {
    for _, tx := range req.Transactions {
        for _, op := range tx.DoOperations {
            switch op.Action {
            case "update":
                handleUpdate(op)
            case "insert":
                handleInsert(op)
            // ... 其他操作
            }
        }
    }
}

func handleUpdate(op *Operation) {
    // 1. 解析 HTML 为 Lute AST
    tree := parseHTML(op.Data)
    
    // 2. 保存 .sy 文件
    saveTree(tree)
    
    // 3. 更新数据库索引
    sql.UpsertTree(tree)
}
```

### 3. HTML 解析为 AST (kernel/model 使用 Lute 库)

```go
import "github.com/88250/lute"

func parseHTML(html string) *parse.Tree {
    luteEngine := lute.New()
    luteEngine.SetTextMark(true)  // 启用 TextMark 支持
    
    // 解析 HTML
    tree := luteEngine.HTML2Tree(html)
    
    // AST 结构示例：
    // NodeDocument
    //   └─ NodeParagraph (id: 20251001111753-36y1un2)
    //        ├─ NodeText: "关键信息是"
    //        ├─ NodeTextMark (TextMarkType: "text")
    //        │    ├─ NodeText: "我爱"
    //        │    └─ NodeKramdownSpanIAL: {: style="background-color: ..."}
    //        └─ NodeText: "你"
    
    return tree
}
```

### 4. 索引到数据库 (kernel/sql/upsert.go)

```go
func upsertTree(tx *sql.Tx, tree *parse.Tree, context map[string]interface{}) error {
    // 1. 从 AST 提取数据
    blocks, spans, assets, attributes := fromTree(tree.Root, tree)
    
    // 2. 删除旧数据
    deleteSpansByRootID(tx, tree.ID)
    deleteAttributesByRootID(tx, tree.ID)
    
    // 3. 插入新数据
    insertBlocks(tx, blocks, context)
    insertSpans(tx, spans)
    insertAttributes(tx, attributes)
    
    return nil
}
```

### 5. 从 AST 提取数据 (kernel/sql/database.go)

```go
func fromTree(node *ast.Node, tree *parse.Tree) (blocks, spans, assets, attributes) {
    ast.Walk(node, func(n *ast.Node, entering bool) ast.WalkStatus {
        if !entering {
            return ast.WalkContinue
        }
        
        // 处理行级元素（span）
        switch n.Type {
        case ast.NodeTextMark:
            span := buildSpanFromTextMark(n, tree)
            spans = append(spans, span)
        }
        
        // 处理属性节点（IAL）
        switch n.Type {
        case ast.NodeKramdownSpanIAL:
            attrs := buildAttributeFromSpanIAL(n, tree)
            attributes = append(attributes, attrs...)
        }
        
        // 处理块级元素
        if n.IsBlock() {
            block := buildBlockFromNode(n, tree)
            blocks = append(blocks, block)
        }
        
        return ast.WalkContinue
    })
    
    return
}

// 构建 Span 记录
func buildSpanFromTextMark(n *ast.Node, tree *parse.Tree) *Span {
    parentBlock := treenode.ParentBlock(n)
    
    return &Span{
        ID:       ast.NewNodeID(),                  // 20251001111832-b574fnd
        BlockID:  parentBlock.ID,                    // 20251001111753-36y1un2
        RootID:   tree.ID,                           // 20251001111753-bo1zbnu
        Box:      tree.Box,                          // 20250927162737-llbshdd
        Path:     tree.Path,                         // /20251001111753-bo1zbnu.sy
        Content:  n.TextMarkTextContent,             // "我爱"
        Markdown: treenode.ExportNodeStdMd(n),       // "<span data-type=\"text\">我爱</span>"
        Type:     "textmark text",                   // 类型标识
        IAL:      treenode.IALStr(n),               // "{: style=\"background-color: ...\"}"
    }
}

// 构建 Attribute 记录
func buildAttributeFromSpanIAL(n *ast.Node, tree *parse.Tree) []*Attribute {
    parentBlock := treenode.ParentBlock(n)
    attrs := parse.IALValMap(n)  // 解析 IAL 为 map
    
    var result []*Attribute
    for name, val := range attrs {
        if !isAttr(name) {  // 只存储特定属性
            continue
        }
        
        result = append(result, &Attribute{
            ID:      ast.NewNodeID(),           // 20251001111832-pjcbyat
            Name:    name,                       // "style"
            Value:   val,                        // "background-color: var(--b3-font-background2);"
            Type:    "s",                        // "s" = span 级属性
            BlockID: parentBlock.ID,             // 20251001111753-36y1un2 (注意：关联到块，不是 span)
            RootID:  tree.ID,
            Box:     tree.Box,
            Path:    tree.Path,
        })
    }
    
    return result
}

// 判断哪些属性需要存到 attributes 表
func isAttr(name string) bool {
    return strings.HasPrefix(name, "custom-") ||
           name == "style" ||
           name == "name" ||
           name == "alias" ||
           name == "memo" ||
           name == "bookmark" ||
           name == "fold" ||
           name == "heading-fold"
}
```

---

## 数据库操作详解

### 1. 表结构设计

```sql
-- blocks 表：存储所有块级元素
CREATE TABLE blocks (
    id          TEXT PRIMARY KEY,   -- 块 ID
    parent_id   TEXT,               -- 父块 ID
    root_id     TEXT,               -- 文档 ID
    hash        TEXT,               -- 内容哈希（用于增量更新）
    box         TEXT,               -- 笔记本 ID
    path        TEXT,               -- 文件路径
    hpath       TEXT,               -- 人类可读路径
    name        TEXT,               -- 块名称
    alias       TEXT,               -- 别名
    memo        TEXT,               -- 备注
    tag         TEXT,               -- 标签
    content     TEXT,               -- 纯文本内容
    fcontent    TEXT,               -- 第一个子块内容
    markdown    TEXT,               -- Markdown 内容（完整）
    length      INT,                -- 内容长度
    type        TEXT,               -- 块类型 (p, h, l, i, d, etc.)
    subtype     TEXT,               -- 子类型
    ial         TEXT,               -- 块级属性列表
    sort        INT,                -- 排序
    created     TEXT,               -- 创建时间
    updated     TEXT                -- 更新时间
);

-- spans 表：存储行级元素
CREATE TABLE spans (
    id          TEXT PRIMARY KEY,   -- Span ID
    block_id    TEXT,               -- 所属块 ID
    root_id     TEXT,               -- 文档 ID
    box         TEXT,               -- 笔记本 ID
    path        TEXT,               -- 文件路径
    content     TEXT,               -- 纯文本内容
    markdown    TEXT,               -- Markdown 表示
    type        TEXT,               -- 类型 (textmark text, textmark tag, image, etc.)
    ial         TEXT                -- 行级属性列表
);
CREATE INDEX idx_spans_root_id ON spans(root_id);

-- attributes 表：存储可查询的属性
CREATE TABLE attributes (
    id          TEXT PRIMARY KEY,   -- 属性 ID
    name        TEXT,               -- 属性名 (style, custom-*, name, alias, etc.)
    value       TEXT,               -- 属性值
    type        TEXT,               -- 类型 ("b"=block级, "s"=span级)
    block_id    TEXT,               -- 关联的块 ID（注意：即使是 span 属性也关联到块）
    root_id     TEXT,               -- 文档 ID
    box         TEXT,               -- 笔记本 ID
    path        TEXT                -- 文件路径
);
CREATE INDEX idx_attributes_block_id ON attributes(block_id);
CREATE INDEX idx_attributes_root_id ON attributes(root_id);
```

### 2. 插入操作 (kernel/sql/upsert.go)

```go
// 批量插入 blocks
func insertBlocks(tx *sql.Tx, blocks []*Block, context map[string]interface{}) error {
    // 每 512 条批量插入
    const batchSize = 512
    
    for i := 0; i < len(blocks); i += batchSize {
        end := min(i+batchSize, len(blocks))
        batch := blocks[i:end]
        
        // 构造 SQL
        stmt := "INSERT INTO blocks (id, parent_id, root_id, ...) VALUES "
        values := []interface{}{}
        
        for _, b := range batch {
            stmt += "(?, ?, ?, ..., ?), "
            values = append(values, b.ID, b.ParentID, b.RootID, ...)
        }
        
        stmt = strings.TrimSuffix(stmt, ", ")
        tx.Exec(stmt, values...)
    }
    
    return nil
}

// 插入 spans（类似的批量逻辑）
func insertSpans(tx *sql.Tx, spans []*Span) error {
    stmt := "INSERT INTO spans (id, block_id, root_id, box, path, content, markdown, type, ial) VALUES "
    // ... 批量插入
}

// 插入 attributes
func insertAttributes(tx *sql.Tx, attributes []*Attribute) error {
    stmt := "INSERT INTO attributes (id, name, value, type, block_id, root_id, box, path) VALUES "
    // ... 批量插入
}
```

### 3. 实际插入的数据

```sql
-- blocks 表插入
INSERT INTO blocks VALUES (
    '20251001111753-36y1un2',                      -- id
    '20251001111753-bo1zbnu',                      -- parent_id (文档块)
    '20251001111753-bo1zbnu',                      -- root_id
    'a1b2c3d4...',                                  -- hash
    '20250927162737-llbshdd',                      -- box
    '/20251001111753-bo1zbnu.sy',                  -- path
    '/高亮测试',                                     -- hpath
    '',                                             -- name
    '',                                             -- alias
    '',                                             -- memo
    '',                                             -- tag
    '关键信息是我爱你',                              -- content (纯文本)
    '',                                             -- fcontent
    '关键信息是<span data-type="text" style="background-color: var(--b3-font-background2);">我爱</span>{: style="background-color: var(--b3-font-background2);"}你',  -- markdown
    8,                                              -- length
    'p',                                            -- type (paragraph)
    '',                                             -- subtype
    '',                                             -- ial
    0,                                              -- sort
    '20251001111753',                               -- created
    '20251001111824'                                -- updated
);

-- spans 表插入
INSERT INTO spans VALUES (
    '20251001111832-b574fnd',                      -- id
    '20251001111753-36y1un2',                      -- block_id
    '20251001111753-bo1zbnu',                      -- root_id
    '20250927162737-llbshdd',                      -- box
    '/20251001111753-bo1zbnu.sy',                  -- path
    '我爱',                                          -- content
    '<span data-type="text" style="background-color: var(--b3-font-background2);">我爱</span>',  -- markdown
    'textmark text',                                -- type
    '{: style="background-color: var(--b3-font-background2);"}'  -- ial
);

-- attributes 表插入
INSERT INTO attributes VALUES (
    '20251001111832-pjcbyat',                      -- id
    'style',                                        -- name
    'background-color: var(--b3-font-background2);',  -- value
    's',                                            -- type (span级)
    '20251001111753-36y1un2',                      -- block_id (关联到父块)
    '20251001111753-bo1zbnu',                      -- root_id
    '20250927162737-llbshdd',                      -- box
    '/20251001111753-bo1zbnu.sy'                   -- path
);
```

### 4. 查询示例

```sql
-- 查询 1: 找到包含高亮文本的所有块
SELECT b.id, b.markdown, s.content, a.value
FROM blocks b
JOIN spans s ON b.id = s.block_id
JOIN attributes a ON b.id = a.block_id
WHERE a.name = 'style' 
  AND a.value LIKE '%background-color%'
  AND a.type = 's';

-- 查询 2: 统计使用了自定义样式的块数量
SELECT COUNT(DISTINCT block_id) as styled_blocks_count
FROM attributes 
WHERE name = 'style' AND type = 's';

-- 查询 3: 查找某个块的所有 spans
SELECT * FROM spans 
WHERE block_id = '20251001111753-36y1un2'
ORDER BY id;

-- 查询 4: 重建完整的块内容（实际不需要，blocks.markdown 已包含完整内容）
SELECT markdown FROM blocks WHERE id = '20251001111753-36y1un2';
```

---

## 插件开发指南

### 1. 插件可以直接复用的内容

#### ✅ **API 层面**

```typescript
// 1. 直接使用思源的 transactions API
import { fetchPost } from "siyuan";

async function applyCustomHighlight(blockId: string, newHTML: string, oldHTML: string) {
    await fetchPost("/api/transactions", {
        session: "plugin-session",
        app: "siyuan",
        transactions: [{
            doOperations: [{
                action: "update",
                id: blockId,
                data: newHTML
            }],
            undoOperations: [{
                action: "update",
                id: blockId,
                data: oldHTML
            }]
        }]
    });
}
```

#### ✅ **DOM 操作层面**

```typescript
// 2. 劫持工具栏（你的 toolbarHijacker.ts 已实现）
import { getAllEditor } from "siyuan";

class ToolbarHijacker {
    hijack() {
        const editors = getAllEditor();
        editors.forEach(editor => {
            const toolbar = editor.protyle.toolbar;
            const originalShowContent = toolbar.showContent.bind(toolbar);
            
            toolbar.showContent = (...args) => {
                // 在原有逻辑前插入自定义按钮
                this.injectCustomButtons(toolbar);
                return originalShowContent(...args);
            };
        });
    }
    
    injectCustomButtons(toolbar) {
        // 添加自定义颜色按钮
        const customColorBtn = document.createElement("button");
        customColorBtn.innerHTML = "🎨";
        customColorBtn.onclick = () => this.applyCustomColor();
        toolbar.element.appendChild(customColorBtn);
    }
}
```

#### ✅ **样式扩展**

```typescript
// 3. 添加自定义颜色
const CUSTOM_COLORS = [
    { name: "荧光黄", value: "#FFFF00" },
    { name: "荧光绿", value: "#00FF00" },
    { name: "荧光粉", value: "#FF00FF" },
];

function applyCustomColor(protyle, color: string) {
    const range = protyle.toolbar.range;
    const blockElement = hasClosestBlock(range.startContainer);
    const oldHTML = blockElement.outerHTML;
    
    // 创建 span
    const span = document.createElement("span");
    span.setAttribute("data-type", "text");
    span.style.backgroundColor = color;
    span.textContent = range.toString();
    
    // 替换选区
    range.deleteContents();
    range.insertNode(span);
    
    // 提交事务
    fetchPost("/api/transactions", {
        session: protyle.id,
        app: "siyuan",
        transactions: [{
            doOperations: [{
                action: "update",
                id: blockElement.getAttribute("data-node-id"),
                data: blockElement.outerHTML
            }],
            undoOperations: [{
                action: "update",
                id: blockElement.getAttribute("data-node-id"),
                data: oldHTML
            }]
        }]
    });
}
```

### 2. 插件不能直接复用的内容

#### ❌ **数据库直接操作**

插件**不能**直接操作数据库，必须通过 API：

```typescript
// ❌ 错误：插件无法直接访问数据库
// const db = sqlite3.open('/data/storage/siyuan.db');
// db.exec("INSERT INTO spans ...");

// ✅ 正确：通过 API 操作
fetchPost("/api/transactions", { ... });  // 后端会自动更新数据库
```

#### ❌ **后端索引逻辑**

插件无法修改后端的索引逻辑（fromTree, buildSpanFromNode 等），只能：
- 使用标准的 HTML 结构（思源会自动解析）
- 使用标准的属性名（style, custom-*, etc.）

### 3. 你的插件当前实现分析

#### 当前代码结构

```
src/
├── index.ts                 # 插件入口
└── utils/
    └── toolbarHijacker.ts   # 工具栏劫持器
```

#### 已实现的功能

```typescript
// src/utils/toolbarHijacker.ts
export class ToolbarHijacker {
    hijack() {
        // ✅ 已实现：劫持工具栏的 showContent 方法
        const originalShowContent = toolbar.showContent.bind(toolbar);
        toolbar.showContent = (...args) => {
            // 注入自定义按钮
            return originalShowContent(...args);
        };
    }
}
```

### 4. 建议的增强方向

#### 方案 A: 扩展颜色选择器

```typescript
// src/utils/colorExtender.ts
export class ColorExtender {
    private customColors = [
        { name: "荧光黄", value: "#FFFF00", icon: "🟡" },
        { name: "荧光绿", value: "#00FF00", icon: "🟢" },
        { name: "荧光粉", value: "#FF00FF", icon: "🟣" },
        { name: "荧光橙", value: "#FFA500", icon: "🟠" },
    ];
    
    injectColorButtons(toolbar: Toolbar) {
        const colorPanel = toolbar.subElement.querySelector(".protyle-font");
        if (!colorPanel) return;
        
        // 添加自定义颜色区域
        const customSection = document.createElement("div");
        customSection.innerHTML = `
            <div class="fn__hr"></div>
            <div>🎨 插件自定义颜色</div>
            <div class="fn__hr--small"></div>
            <div class="fn__flex fn__flex-wrap">
                ${this.customColors.map(c => `
                    <button class="color__square" 
                            style="background-color:${c.value}" 
                            data-type="backgroundColor"
                            title="${c.name}">
                    </button>
                `).join('')}
            </div>
        `;
        
        colorPanel.appendChild(customSection);
    }
}
```

#### 方案 B: 高亮模板

```typescript
// src/utils/highlightTemplates.ts
export class HighlightTemplates {
    private templates = {
        important: {
            backgroundColor: "var(--b3-card-error-background)",
            color: "var(--b3-card-error-color)",
            fontWeight: "bold"
        },
        info: {
            backgroundColor: "var(--b3-card-info-background)",
            color: "var(--b3-card-info-color)"
        },
        quote: {
            backgroundColor: "transparent",
            borderLeft: "3px solid var(--b3-theme-primary)",
            paddingLeft: "8px",
            fontStyle: "italic"
        }
    };
    
    applyTemplate(protyle: IProtyle, templateName: string) {
        const style = this.templates[templateName];
        const range = protyle.toolbar.range;
        
        // 创建 span 并应用样式
        const span = document.createElement("span");
        span.setAttribute("data-type", "text");
        Object.assign(span.style, style);
        span.textContent = range.toString();
        
        // 提交事务...
    }
}
```

#### 方案 C: 快捷键支持

```typescript
// src/utils/keyboardShortcuts.ts
export class KeyboardShortcuts {
    register(plugin: Plugin) {
        // 注册快捷键 Ctrl+Shift+H
        document.addEventListener("keydown", (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === "H") {
                e.preventDefault();
                this.quickHighlight();
            }
        });
    }
    
    private quickHighlight() {
        const editors = getAllEditor();
        editors.forEach(editor => {
            const toolbar = editor.protyle.toolbar;
            // 应用默认高亮色
            applyCustomColor(editor.protyle, "#FFFF00");
        });
    }
}
```

### 5. 完整的插件示例

```typescript
// src/index.ts (增强版)
import { Plugin, getAllEditor, fetchPost } from "siyuan";
import { ToolbarHijacker } from "./utils/toolbarHijacker";
import { ColorExtender } from "./utils/colorExtender";
import { HighlightTemplates } from "./utils/highlightTemplates";
import { KeyboardShortcuts } from "./utils/keyboardShortcuts";

export default class HighlightAssistantPlugin extends Plugin {
    private hijacker: ToolbarHijacker;
    private colorExtender: ColorExtender;
    private templates: HighlightTemplates;
    private shortcuts: KeyboardShortcuts;
    
    async onload() {
        // 1. 初始化各模块
        this.hijacker = new ToolbarHijacker();
        this.colorExtender = new ColorExtender();
        this.templates = new HighlightTemplates();
        this.shortcuts = new KeyboardShortcuts();
        
        // 2. 劫持工具栏
        this.hijacker.hijack();
        
        // 3. 注入自定义颜色
        this.hijacker.onToolbarShow = (toolbar) => {
            this.colorExtender.injectColorButtons(toolbar);
        };
        
        // 4. 注册快捷键
        this.shortcuts.register(this);
        
        // 5. 添加顶栏按钮
        this.addTopBar({
            icon: "iconHighlight",
            title: "快速高亮",
            callback: () => this.showQuickMenu()
        });
    }
    
    private showQuickMenu() {
        // 显示快捷菜单
        const menu = new Menu("highlight-menu");
        menu.addItem({
            icon: "iconInfo",
            label: "重要",
            click: () => this.templates.applyTemplate(this.getCurrentProtyle(), "important")
        });
        menu.addItem({
            icon: "iconHelp",
            label: "提示",
            click: () => this.templates.applyTemplate(this.getCurrentProtyle(), "info")
        });
        menu.open();
    }
    
    private getCurrentProtyle() {
        const editors = getAllEditor();
        return editors[0]?.protyle;  // 获取当前编辑器
    }
}
```

### 6. 数据库查询（插件可以使用）

虽然插件不能直接操作数据库，但可以通过 API 查询：

```typescript
// 查询包含高亮的块
async function findHighlightedBlocks() {
    const result = await fetchPost("/api/query/sql", {
        stmt: `
            SELECT b.id, b.content, b.markdown, a.value as style_value
            FROM blocks b
            JOIN attributes a ON b.id = a.block_id
            WHERE a.name = 'style' 
              AND a.type = 's'
              AND a.value LIKE '%background-color%'
            LIMIT 100
        `
    });
    
    return result.data;
}

// 统计高亮使用情况
async function getHighlightStats() {
    const result = await fetchPost("/api/query/sql", {
        stmt: `
            SELECT 
                COUNT(DISTINCT block_id) as block_count,
                COUNT(*) as span_count
            FROM attributes
            WHERE name = 'style' AND type = 's'
        `
    });
    
    return result.data[0];
}
```

### 7. 注意事项

#### ⚠️ **事务处理**

- 所有修改必须通过 `/api/transactions`
- doOperations 和 undoOperations 必须配对
- 不要跳过事务直接修改 DOM（会导致数据不一致）

#### ⚠️ **HTML 结构**

```html
<!-- ✅ 正确：使用标准结构 -->
<span data-type="text" style="background-color: #FFFF00;">高亮文本</span>

<!-- ❌ 错误：自定义属性不会被索引 -->
<span class="my-highlight" data-my-color="#FFFF00">高亮文本</span>
```

#### ⚠️ **属性命名**

```typescript
// ✅ 会被索引到 attributes 表
span.style.backgroundColor = "#FFFF00";  // → attributes (name=style)
span.setAttribute("custom-highlight-level", "3");  // → attributes (name=custom-highlight-level)

// ❌ 不会被索引
span.setAttribute("data-highlight", "true");  // 不符合 isAttr() 规则
span.className = "highlight";  // class 不会被索引到 attributes
```

#### ⚠️ **性能考虑**

- 批量操作时使用单个事务
- 避免频繁的小事务
- 大量数据查询时使用分页

```typescript
// ❌ 性能差：每个块一个事务
blocks.forEach(block => {
    fetchPost("/api/transactions", { ... });
});

// ✅ 性能好：批量操作
fetchPost("/api/transactions", {
    transactions: [{
        doOperations: blocks.map(block => ({
            action: "update",
            id: block.id,
            data: block.newHTML
        })),
        undoOperations: blocks.map(block => ({
            action: "update",
            id: block.id,
            data: block.oldHTML
        }))
    }]
});
```

---

## 总结

### 完整的高亮样式实现涉及：

1. **前端行为** (5个关键步骤)
   - 选择文本 (Selection API)
   - 触发工具栏 (Font.ts)
   - 创建 Span (setInlineMark)
   - 应用样式 (setFontStyle)
   - 提交事务 (updateTransaction)

2. **API 接口** (1个核心接口)
   - POST `/api/transactions`
   - 包含 doOperations 和 undoOperations
   - 支持 update/insert/delete/move 操作

3. **后端处理** (4个处理层)
   - API 层：接收请求
   - 模型层：处理事务
   - 解析层：HTML → AST
   - 索引层：AST → 数据库

4. **数据库操作** (3个表 + 批量插入)
   - blocks：存储完整块内容
   - spans：存储行级元素（便于搜索）
   - attributes：存储可查询属性（便于筛选）

5. **插件开发** (✅ 可复用 + ❌ 不可复用)
   - ✅ 可以：劫持工具栏、扩展颜色、添加快捷键、使用 API
   - ❌ 不能：直接操作数据库、修改后端逻辑

6. **其他重要信息**
   - IAL (Inline Attribute List) 是核心概念
   - 属性双重存储：spans.ial + attributes 表
   - span 属性关联到父块，不是 span 自身
   - 批量操作优于单个操作
   - 必须使用标准的 HTML 结构和属性名

### 你的插件可以做什么？

1. **扩展颜色选择器** - 添加更多预设颜色
2. **高亮模板** - 一键应用预设样式组合
3. **快捷键** - Ctrl+Shift+数字键快速应用颜色
4. **统计面板** - 显示高亮使用情况
5. **批量操作** - 批量修改/清除高亮
6. **导出功能** - 导出高亮笔记为 HTML/PDF

所有这些都可以通过劫持工具栏 + 调用 `/api/transactions` 实现，无需修改思源核心代码！

