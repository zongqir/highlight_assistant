# 状态识别时机汇总

**更新日期**: 2025-10-02  
**版本**: v1.2.1

## 🎯 当前触发识别锁状态的时机

### 1️⃣ **点击锁按钮时** ✅ 已实现（新增）
**触发位置**: `readonlyStateMonitor.ts`
```typescript
// 事件代理监听锁按钮点击
document.addEventListener('click', (e) => {
    const readonlyBtn = target.closest('button[data-type="readonly"]');
    if (readonlyBtn) {
        // 延迟150ms后获取最新状态
        setTimeout(() => this.updateState(), 150);
    }
}, true);
```

**特点**：
- ✅ 主动监听，立即响应
- ✅ 使用事件代理，不会遗漏
- ✅ 延迟150ms等待思源处理完成
- ✅ 通知所有订阅者（如工具栏管理器）

---

### 2️⃣ **Tab切换时** ✅ 已实现（已有）
**触发位置**: `toolbarHijacker.ts`

#### 方法1: 监听 protyle 模式切换事件
```typescript
eventBus.addEventListener('message', (event) => {
    if (data.cmd === 'switch-protyle-mode') {
        Logger.log('🔄 检测到protyle模式切换事件');
        this.refreshEditingStateCache();
    }
});
```

#### 方法2: 监听窗口焦点变化
```typescript
window.addEventListener('focus', handleFocus);
document.addEventListener('focusin', handleFocus);
```

#### 方法3: 监听DOM变化
```typescript
new MutationObserver((mutations) => {
    // 检测 .layout-tab-container 或 .protyle-wysiwyg 的变化
    if (hasTabChange) {
        this.refreshEditingStateCache();
    }
});
```

#### 方法4: 监听选择变化
```typescript
document.addEventListener('selectionchange', () => {
    if (activeElement !== lastActiveElement) {
        this.refreshEditingStateCache();
    }
});
```

**特点**：
- ✅ 多重备用方案，确保不遗漏
- ⚠️ **注意**：这些监听主要是刷新 `editingStateCache`，不直接调用 `readonlyStateMonitor`

---

### 3️⃣ **选中文本显示工具栏前** ✅ 已实现
**触发位置**: `customToolbarManager.ts` 第87行

```typescript
setupMouseSelectionListener(): void {
    const handleSelection = () => {
        // 🔍 在工具栏显示之前检查当前活跃文档的只读状态
        const readonlyBtn = getCurrentActiveReadonlyButton();
        
        if (readonlyBtn) {
            const iconHref = readonlyBtn.querySelector('use')?.getAttribute('xlink:href') || '';
            isDocReadonly = iconHref !== '#iconUnlock';
        }
        
        // 🔒 只有在加锁（只读）状态下才显示高亮工具栏
        if (!isDocReadonly) {
            return;
        }
        
        // 显示工具栏...
    };
}
```

**特点**：
- ✅ 每次选中文本都检查
- ✅ 使用统一的 `getCurrentActiveReadonlyButton()`
- ✅ 防止在解锁状态下显示工具栏

---

### 4️⃣ **点击高亮文本时** ✅ 已实现
**触发位置**: `highlightClickManager.ts` 第159行

```typescript
private showDeleteConfirmDialog(highlightElement: HTMLElement): void {
    // 🔒 检查文档是否处于锁定编辑状态（只读模式）
    const isDocReadonly = isCurrentDocumentReadonly();
    
    if (!isDocReadonly) {
        Logger.log('⛔ 文档未锁定（可编辑状态），不显示快速删除对话框');
        return;
    }
    
    Logger.log('✅ 文档已锁定（只读状态），显示快速删除对话框');
    // 显示删除对话框...
}
```

**特点**：
- ✅ 点击高亮前检查
- ✅ 使用统一的 `isCurrentDocumentReadonly()`
- ✅ 只在锁定状态下允许删除

---

### 5️⃣ **右键/长按块（标签功能）时** ✅ 已实现
**触发位置**: `tagManager.ts`

#### 桌面版：右键时
```typescript
// 第87行
document.addEventListener('contextmenu', (e) => {
    const blockElement = this.findBlockElementFromNode(target);
    
    if (blockElement) {
        // 检查是否处于只读状态
        const isDocReadonly = isCurrentDocumentReadonly();
        
        if (isDocReadonly) {
            e.preventDefault();
            this.showTagPanel(blockElement);
        }
    }
});
```

#### 手机版：长按时
```typescript
// 第117行
document.addEventListener('touchstart', (e) => {
    touchTimer = setTimeout(() => {
        // 检查是否处于只读状态
        const isDocReadonly = isCurrentDocumentReadonly();
        
        if (isDocReadonly) {
            this.showTagPanel(blockElement);
        }
    }, 500);
});
```

**特点**：
- ✅ 右键/长按前检查
- ✅ 使用统一的 `isCurrentDocumentReadonly()`
- ✅ 只在锁定状态下允许打标签

---

### 6️⃣ **执行写入操作前（兜底防御）** ✅ 已实现
**触发位置**: `operationWrapper.ts` 第49行

```typescript
public async executeWithUnlockLock<T>(
    operationName: string, 
    operation: () => Promise<T>
): Promise<T | null> {
    Logger.log(`🚀 开始执行写入操作: ${operationName}`);
    
    // 🛡️ 兜底防御：检查文档是否处于可编辑状态，如果是则拒绝操作
    if (isCurrentDocumentEditable()) {
        Logger.error(`🛡️ 兜底防御触发：文档处于可编辑状态，拒绝执行 ${operationName} 操作`);
        throw new Error(`文档未锁定，禁止执行 ${operationName} 操作`);
    }
    
    // 步骤1: 🔓 无脑解锁
    const unlocked = await this.forceUnlock(operationName);
    
    // 步骤2: ⚡ 执行操作
    result = await operation();
    
    // 步骤3: 🔒 无脑加锁
    await this.forceLock(operationName);
}
```

**特点**：
- ✅ 执行操作前检查（第49行使用 `isCurrentDocumentEditable()`）
- ⚠️ **问题**：forceUnlock 和 forceLock 里的锁按钮获取没用统一工具！

---

## ✅ 已修复的问题

### operationWrapper 中的锁按钮获取方式已统一

**修复前**（第84行和第123行）：
```typescript
// ❌ 直接用 document.querySelector，可能拿错tab
const readonlyBtn = document.querySelector('.protyle-breadcrumb button[data-type="readonly"]');
```

**修复后**：
```typescript
// ✅ 使用统一工具，获取当前活跃tab的锁按钮
const readonlyBtn = getCurrentActiveReadonlyButton();
```

**修复内容**：
- ✅ forceUnlock() 方法已使用统一工具（第85行）
- ✅ forceLock() 方法已使用统一工具（第125行）
- ✅ 确保在多tab场景下操作正确的锁按钮

---

## 📊 触发时机对比表

| 时机 | 位置 | 使用统一工具 | 实时性 | 备注 |
|------|------|------------|--------|------|
| **点击锁按钮** | readonlyStateMonitor | ✅ | ⚡ 立即 | 新增，主动监听 |
| **Tab切换** | toolbarHijacker | ❌ | ⏱️ 延迟 | 刷新editingStateCache |
| **选中文本** | customToolbarManager | ✅ | ⏱️ 触发时 | 每次选中都检查 |
| **点击高亮** | highlightClickManager | ✅ | ⏱️ 触发时 | 点击时检查 |
| **右键/长按块** | tagManager | ✅ | ⏱️ 触发时 | 操作前检查 |
| **写入操作前** | operationWrapper | ✅ | ⏱️ 触发时 | 兜底防御 |
| **强制解锁** | operationWrapper | ✅ | ⏱️ 触发时 | ✅ **已修复** |
| **强制加锁** | operationWrapper | ✅ | ⏱️ 触发时 | ✅ **已修复** |

---

## 🔄 完整流程图

### 用户点击锁按钮后的完整链路

```
用户点击锁按钮 🔒
    ↓
┌─────────────────────────────────────┐
│ 1. readonlyStateMonitor 捕获点击   │
│    (事件代理 + MutationObserver)     │
└─────────────────────────────────────┘
    ↓ 150ms延迟
┌─────────────────────────────────────┐
│ 2. 调用 getCurrentActiveReadonlyButton() │
│    → 获取当前tab的锁按钮             │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 3. 调用 isCurrentDocumentReadonly() │
│    → 判断新的状态                    │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 4. 比较新旧状态                      │
│    → 如果改变，通知订阅者            │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 5. CustomToolbarManager 收到通知   │
│    → 如果解锁，立即隐藏工具栏        │
└─────────────────────────────────────┘
```

### 用户选中文本的流程

```
用户选中文本
    ↓
┌─────────────────────────────────────┐
│ 1. customToolbarManager 检测选区    │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 2. 调用 getCurrentActiveReadonlyButton() │
│    → 获取当前tab的锁按钮             │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 3. 检查图标href判断是否只读          │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 4. 如果只读，显示工具栏              │
│    如果可编辑，不显示                │
└─────────────────────────────────────┘
```

---

## 🎯 总结

### 已实现的触发时机（6个）

1. ✅ **点击锁按钮** - 主动监听，立即响应
2. ✅ **Tab切换** - 多重监听，刷新状态缓存
3. ✅ **选中文本** - 显示工具栏前检查
4. ✅ **点击高亮** - 删除前检查
5. ✅ **右键/长按** - 打标签前检查
6. ✅ **写入操作前** - 兜底防御检查

### ~~需要优化的地方（2处）~~ ✅ 已全部修复

1. ✅ **operationWrapper.forceUnlock** (第85行) - 已使用 `getCurrentActiveReadonlyButton()`
2. ✅ **operationWrapper.forceLock** (第125行) - 已使用 `getCurrentActiveReadonlyButton()`

### 回答你的问题

> "整理下 目前是点击了锁 和tab切换 都会识别一下 对吗?"

✅ **对的！**
- **点击锁** → readonlyStateMonitor 立即捕获并识别
- **Tab切换** → toolbarHijacker 多种方式监听并刷新状态

> "还有什么时候会识别?"

✅ **还有4个时机**：
- 选中文本时
- 点击高亮文本时
- 右键/长按块时
- 执行写入操作前（兜底防御）

> "我记得我还有个wrapper 你那里改了吗?"

✅ **已全部改完**：
- ✅ 第49行的 `isCurrentDocumentEditable()` 检查已使用统一工具
- ✅ 第85行的 `forceUnlock()` 里的锁按钮获取**已修复**
- ✅ 第125行的 `forceLock()` 里的锁按钮获取**已修复**

**修复完成**：现在 operationWrapper 的所有地方都使用统一的 `getCurrentActiveReadonlyButton()` 工具！

---

**更新日期**: 2025-10-02  
**状态**: ✅ 6个触发时机已实现 + operationWrapper 已完全统一  
**构建**: ✅ 成功 (178.94 kB │ gzip: 47.06 kB)

