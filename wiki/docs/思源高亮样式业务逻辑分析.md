# 思源笔记：给文本添加样式的完整业务逻辑

## 一、核心流程图

```
用户操作（选中文本 → 点击高亮）
    ↓
前端创建 NodeTextMark 节点
    ↓
添加 IAL（Inline Attribute List）: {: style="background-color: ..."}
    ↓
保存 .sy 文档（序列化 AST）
    ↓
触发索引：fromTree() 函数
    ↓
并行写入三个表：blocks、spans、attributes
```

## 二、关键代码路径

### 1. 文档索引入口 (`kernel/sql/upsert.go`)

```go
// 当文档保存时调用
func indexTree(tx *sql.Tx, tree *parse.Tree, context map[string]interface{}) (err error) {
    // 从文档树中提取所有数据
    blocks, spans, assets, attributes := fromTree(tree.Root, tree)
    refs, fileAnnotationRefs := refsFromTree(tree)
    
    // 批量插入数据库
    err = insertTree0(tx, tree, context, blocks, spans, assets, attributes, refs, fileAnnotationRefs)
    return
}
```

### 2. 遍历文档树 (`kernel/sql/database.go:508`)

```go
func fromTree(node *ast.Node, tree *parse.Tree) (blocks, spans, assets, attributes) {
    ast.Walk(node, func(n *ast.Node, entering bool) ast.WalkStatus {
        // 第一步：处理行级元素（包括 TextMark）
        spanBlocks, spanSpans, spanAssets, spanAttrs, walkStatus := buildSpanFromNode(n, tree, ...)
        if 0 < len(spanSpans) {
            spans = append(spans, spanSpans...)  // 收集到 spans 表数据
        }
        if 0 < len(spanAttrs) {
            attributes = append(attributes, spanAttrs...)
        }

        // 第二步：处理属性节点（IAL）
        attrs := buildAttributeFromNode(n, rootID, boxID, p)
        if 0 < len(attrs) {
            attributes = append(attributes, attrs...)  // 收集到 attributes 表数据
        }

        // 第三步：处理块级元素
        if n.IsBlock() {
            b, attrs := buildBlockFromNode(n, tree)
            blocks = append(blocks, b)  // 收集到 blocks 表数据
            attributes = append(attributes, attrs...)
        }
    })
}
```

### 3. 构建 Span 记录 (`kernel/sql/database.go:668`)

```go
case ast.NodeTextMark:
    // 提取类型：例如 "textmark text" 或 "textmark tag"
    typ := treenode.TypeAbbr(n.Type.String()) + " " + n.TextMarkType
    
    // 提取纯文本内容
    text := strings.TrimSuffix(n.Content(), string(gulu.ZWJ))
    
    // 导出为标准 markdown
    markdown := treenode.ExportNodeStdMd(n, luteEngine)
    
    // 获取父块 ID
    parentBlock := treenode.ParentBlock(n)
    
    // 创建 span 记录
    span := &Span{
        ID:       ast.NewNodeID(),
        BlockID:  parentBlock.ID,           // 关联到父块
        RootID:   rootID,
        Box:      boxID,
        Path:     p,
        Content:  text,                     // "我爱"
        Markdown: markdown,                 // "<span ...>我爱</span>"
        Type:     typ,                      // "textmark text"
        IAL:      treenode.IALStr(n),      // "{: style=\"...\"}"
    }
    spans = append(spans, span)
```

### 4. 构建 Attribute 记录 (`kernel/sql/database.go:556`)

```go
func buildAttributeFromNode(n *ast.Node, rootID, boxID, p string) (attributes []*Attribute) {
    switch n.Type {
    case ast.NodeKramdownSpanIAL:  // Span 级别的属性（就是你的场景）
        parentBlock := treenode.ParentBlock(n)
        attrs := parse.IALValMap(n)  // 解析 IAL 为 map
        
        for name, val := range attrs {
            // 只存储特定的属性到 attributes 表
            if !isAttr(name) {  // style、name、alias、memo、custom-* 等
                continue
            }

            attr := &Attribute{
                ID:      ast.NewNodeID(),
                Name:    name,                // "style"
                Value:   val,                 // "background-color: var(--b3-font-background2);"
                Type:    "s",                 // "s" 表示 span 级属性
                BlockID: parentBlock.ID,      // 关联到父块，不是 span ID！
                RootID:  rootID,
                Box:     boxID,
                Path:    p,
            }
            attributes = append(attributes, attr)
        }
    }
}

// 判断哪些属性需要存到 attributes 表
func isAttr(name string) bool {
    return strings.HasPrefix(name, "custom-") || 
           "name" == name || 
           "alias" == name || 
           "memo" == name || 
           "bookmark" == name || 
           "fold" == name || 
           "heading-fold" == name || 
           "style" == name  // ← 你的高亮样式
}
```

## 三、为什么需要三个表？

### 1. **blocks 表** - 主体存储
- 存储所有块级元素（段落、标题、列表、文档等）
- 支持全文搜索（FTS）
- 作为其他表的主键关联
- **你的例子**：存储包含 "关键信息是我爱你" 的段落块

### 2. **spans 表** - 行级元素索引
- 专门存储行级元素（图片、标签、文本标记、链接等）
- 用于搜索和统计（例如：搜索所有带某个标签的内容）
- 存储完整的 IAL 信息，但不拆分
- **你的例子**：单独记录 "我爱" 这个高亮文本，方便搜索 "type=textmark text" 的所有元素

### 3. **attributes 表** - 属性查询优化
- 将 IAL 中的**特定属性**拆分存储
- 支持按属性筛选（SQL WHERE）
- 只存储有查询价值的属性（style、custom-*、name 等）
- **你的例子**：将 style 属性单独提取，方便查询 "所有有背景色样式的块"

### 4. **设计理由**

```sql
-- 场景1：找到包含 "我爱" 的所有文本标记
SELECT * FROM spans WHERE type LIKE 'textmark%' AND content LIKE '%我爱%';

-- 场景2：找到所有有自定义样式的块
SELECT * FROM attributes WHERE name = 'style';

-- 场景3：找到某个块的完整内容
SELECT * FROM blocks WHERE id = '20251001111753-36y1un2';

-- 场景4：联合查询 - 找到有背景色样式的段落块
SELECT b.* 
FROM blocks b 
JOIN attributes a ON b.id = a.block_id 
WHERE a.name = 'style' AND a.value LIKE '%background-color%';
```

## 四、关键业务逻辑总结

### 1. **属性存储的双重性**

```typescript
// IAL 属性同时存在两个地方：

// 1. spans 表的 ial 字段（完整保存，用于重建）
{
  ial: "{: style=\"background-color: var(--b3-font-background2);\" custom-data=\"test\"}"
}

// 2. attributes 表（拆分存储，用于查询）
[
  { name: "style", value: "background-color: var(--b3-font-background2);" },
  { name: "custom-data", value: "test" }
]
```

### 2. **你可能忽略的细节**

#### ① **Span 不直接关联 Attribute**
```sql
-- 注意！attributes.block_id 指向的是父块，不是 span ID
-- 这意味着：
-- - 对于块级属性：block_id = 块的 ID
-- - 对于 span 级属性：block_id = 包含这个 span 的块 ID
```

从你的数据可以验证：
```sql
-- span 记录
span_id: 20251001111832-b574fnd
block_id: 20251001111753-36y1un2  (父块)

-- attribute 记录
attr_id: 20251001111832-pjcbyat
block_id: 20251001111753-36y1un2  (也是父块，不是 span_id)
```

#### ② **type 字段的含义**
- `attributes.type = 's'`：表示这是 **Span 级属性**（来自 NodeKramdownSpanIAL）
- `attributes.type = 'b'`：表示这是 **Block 级属性**（来自 NodeKramdownBlockIAL）

#### ③ **只有特定属性才会进 attributes 表**
并非所有 IAL 都会存到 attributes 表，只有这些会：
- `style`
- `name`
- `alias`
- `memo`
- `bookmark`
- `fold`
- `heading-fold`
- `custom-*` 开头的属性

其他属性只保留在 `spans.ial` 或 `blocks.ial` 字段中。

### 3. **完整的生命周期**

```
编辑器操作
    ↓
1. 前端创建/更新 DOM 节点
   <span data-type="text" style="background-color: var(--b3-font-background2);">我爱</span>

    ↓
2. 解析为 AST 节点
   NodeTextMark {
       TextMarkType: "text",
       Content: "我爱",
       IAL: {style: "background-color: ..."}
   }

    ↓
3. 序列化保存为 .sy 文件
   关键信息是<span data-type="text" style="...">我爱</span>{: style="..."}你

    ↓
4. 触发数据库索引
   - fromTree() 遍历 AST
   - buildSpanFromNode() 创建 span 记录
   - buildAttributeFromNode() 创建 attribute 记录
   - insertTree0() 批量插入数据库

    ↓
5. 数据库状态
   blocks 表：1 条记录（段落块，包含完整 markdown）
   spans 表：1 条记录（textmark text，"我爱"，包含 IAL）
   attributes 表：1 条记录（style 属性，方便查询）
```

## 五、你可能遇到的混淆点

### ❓ 为什么 attributes 不直接关联到 span？

**答**：因为思源的查询模型是以 **block** 为中心的。

```sql
-- 思源的典型查询模式：
-- 1. 找到符合条件的块
-- 2. 加载块的完整内容（包括所有 spans）

-- 如果 attributes 关联到 span：
SELECT b.* FROM blocks b
JOIN spans s ON b.id = s.block_id
JOIN attributes a ON s.id = a.span_id  -- 需要多一次 join
WHERE a.name = 'style';

-- 现在的设计（attributes 关联到 block）：
SELECT b.* FROM blocks b
JOIN attributes a ON b.id = a.block_id  -- 直接 join
WHERE a.name = 'style' AND a.type = 's';  -- 用 type 区分 span 属性
```

这样设计的好处：
- 减少一次 JOIN，提升查询性能
- 块是最小的操作单位，找到块就能完整呈现内容
- 简化索引结构

### ❓ 如果一个块内有多个高亮，怎么区分？

**答**：通过 `spans` 表区分，但 `attributes` 表会有多条记录。

```sql
-- 假设段落：<span style="...">文本1</span> 和 <span style="...">文本2</span>

-- spans 表：
| id      | block_id | content | type          | ial              |
|---------|----------|---------|---------------|------------------|
| span-01 | block-x  | 文本1   | textmark text | {: style="..."} |
| span-02 | block-x  | 文本2   | textmark text | {: style="..."} |

-- attributes 表：
| id       | block_id | name  | value               | type |
|----------|----------|-------|---------------------|------|
| attr-01  | block-x  | style | background-color... | s    |
| attr-02  | block-x  | style | background-color... | s    |
```

**重点**：attributes 表只用于**筛选**，不用于**精确定位**。精确定位靠 spans 表。

## 六、实际应用场景

### 场景 1：搜索所有高亮文本

```sql
SELECT b.markdown, s.content, s.ial
FROM blocks b
JOIN spans s ON b.id = s.block_id
WHERE s.type LIKE 'textmark%' 
  AND s.ial LIKE '%background-color%';
```

### 场景 2：统计使用了自定义样式的块数量

```sql
SELECT COUNT(DISTINCT block_id) 
FROM attributes 
WHERE name = 'style' AND type = 's';
```

### 场景 3：查找某个块的所有 spans

```sql
SELECT * FROM spans WHERE block_id = '20251001111753-36y1un2';
```

### 场景 4：重建文档内容

```sql
-- 1. 读取块的 markdown（已包含完整内容）
SELECT markdown FROM blocks WHERE id = 'xxx';

-- 不需要再查 spans，因为 markdown 字段是完整的！
-- spans 表主要用于搜索和统计，不是重建文档用的
```

## 七、性能优化考虑

### 1. **批量插入**
```go
// upsert.go 中的优化
func insertSpans(tx *sql.Tx, spans []*Span) {
    var bulk []*Span
    for _, span := range spans {
        bulk = append(bulk, span)
        if 512 > len(bulk) {  // 每 512 条批量插入一次
            continue
        }
        insertSpans0(tx, bulk)
        bulk = []*Span{}
    }
}
```

### 2. **索引设计**
```sql
CREATE INDEX idx_spans_root_id ON spans(root_id);
CREATE INDEX idx_attributes_block_id ON attributes(block_id);
CREATE INDEX idx_attributes_root_id ON attributes(root_id);
```

### 3. **增量更新**
```go
// upsertTree 函数通过 hash 判断块是否变化
oldBlockHashes := queryBlockHashes(tree.ID)
newBlockHashes := ...
// 只更新变化的块，未变化的块不重新插入
```

## 八、总结

### 给文本添加样式需要操作的表：

| 表名 | 作用 | 记录数 | 是否必须 |
|------|------|--------|----------|
| blocks | 存储段落块 | 1 | ✅ 必须 |
| spans | 存储高亮文本的行级元素 | 1 | ✅ 必须 |
| attributes | 存储 style 属性便于查询 | 1 | ⚠️ 可选（取决于是否需要按属性查询）|

### 核心业务逻辑：

1. **数据冗余设计**：
   - markdown 内容在 `blocks.markdown` 中完整保存
   - 拆分的 span 信息在 `spans` 表中保存
   - 可查询的属性在 `attributes` 表中保存
   - 这是典型的"空间换时间"策略

2. **关联关系**：
   ```
   blocks (1) ←→ (N) spans
   blocks (1) ←→ (N) attributes
   spans 和 attributes 之间没有直接关联
   ```

3. **查询策略**：
   - 需要完整内容 → 查 blocks.markdown
   - 需要搜索特定类型的行级元素 → 查 spans
   - 需要按属性筛选 → 查 attributes
   - 需要联合信息 → JOIN 查询

4. **你之前可能忽略的逻辑**：
   - ✅ 属性同时存在于 IAL 字段和 attributes 表
   - ✅ attributes 关联到块而非 span
   - ✅ 只有特定属性才会进 attributes 表
   - ✅ type='s' 标记这是 span 级属性
   - ✅ 批量插入和增量更新优化

