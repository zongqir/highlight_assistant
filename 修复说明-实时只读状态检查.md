# 修复说明 - 实时只读状态检查

**更新日期**: 2025-10-01  
**版本**: v1.1.2

## 🐛 问题描述

你发现了一个关键问题：

> **"你在弹窗触发的时候需要检查下文档的只读状态，你这个检查如果是第一次，那必然有问题啊"**

### 问题原因

之前的实现中：
1. ❌ 只在 `showContent` 被触发时检查一次只读状态
2. ❌ 那时候只是工具栏显示，还没到真正的弹窗
3. ❌ 第一次检查时 DOM 可能还没准备好
4. ❌ 没有在真正显示弹窗时再次检查

## ✅ 修复方案

### 关键改进

在**真正执行操作时实时检查**文档只读状态：

1. **显示备注弹窗时** - `showEnhancedMemoInput()`
2. **应用高亮时** - `applyHighlight()`

### 查找策略

使用**多重查找策略**确保找到正确的 `protyle-wysiwyg` 元素：

#### 备注弹窗 (`showEnhancedMemoInput`)
```typescript
// 方式1: 从当前选区查找（最准确）
const selection = window.getSelection();
// 向上查找 .protyle-wysiwyg 元素

// 方式2: 查找带 attr 属性的
document.querySelector('.protyle-wysiwyg.protyle-wysiwyg--attr')

// 方式3: 查找任意可见的编辑器
遍历所有 .protyle-wysiwyg，找第一个可见的
```

#### 应用高亮 (`applyHighlight`)
```typescript
// 方式1: 从传入的 range 参数查找（最准确）
从 range.startContainer 向上查找

// 方式2: 备用查找
document.querySelector('.protyle-wysiwyg.protyle-wysiwyg--attr')
```

## 📝 新增的调试日志

### 1. 备注弹窗显示时
```
[ToolbarHijacker] 🎨 ========== 准备显示备注输入弹窗 ==========
[ToolbarHijacker] 📋 当前文档只读状态 (实时检查): {
  custom-sy-readonly: "true",
  是否只读: "是🔒（锁已锁定）",
  查找方式: "从当前文档",
  弹窗状态: "即将显示"
}
[ToolbarHijacker] 📝 弹窗参数: {
  selectedText: "选中的文本...",
  existingContent: "",
  hasExisting: false
}
```

### 2. 应用高亮时
```
[ToolbarHijacker] 🎨 ========== 应用高亮操作 ==========
[ToolbarHijacker] 📋 当前文档只读状态 (实时检查): {
  custom-sy-readonly: "true",
  是否只读: "是🔒（锁已锁定）",
  操作: "即将应用高亮"
}
[ToolbarHijacker] 🔒 文档处于只读模式，继续执行高亮操作
[ToolbarHijacker] 🎨 高亮参数: {
  color: "黄色",
  text: "要高亮的文本..."
}
```

## 🎯 关键特征

### "实时检查" 的含义

| 检查时机 | 之前 | 现在 |
|---------|------|------|
| **工具栏触发时** | ✅ 检查一次 | ✅ 检查一次（保留） |
| **显示弹窗时** | ❌ 不检查 | ✅ **实时检查** |
| **应用高亮时** | ❌ 不检查 | ✅ **实时检查** |

### 日志标识

所有实时检查的日志都带有 `(实时检查)` 标记：

```
📋 当前文档只读状态 (实时检查):  ← 注意这个标记
```

## 🧪 测试方法

### 完整测试流程

1. **重启思源笔记**
2. **打开控制台** (F12)
3. **打开一个文档**
4. **点击锁图标** 🔒（确保文档处于只读模式）
5. **选中一段文本**
6. **观察工具栏触发时的日志**
   ```
   [ToolbarHijacker] 🎯 ========== 工具栏 showContent 被触发 ==========
   [ToolbarHijacker] 📊 只读状态汇总: { ... }
   ```
7. **点击备注按钮或高亮按钮**
8. **观察实时检查的日志** ⭐️
   ```
   [ToolbarHijacker] 🎨 ========== 准备显示备注输入弹窗 ==========
   [ToolbarHijacker] 📋 当前文档只读状态 (实时检查): { ... }
   ```

### 重点观察

**第一次加载时：**
- ✅ 工具栏触发时检查一次
- ✅ **弹窗显示前再检查一次** ← 这是新增的！

**切换锁状态后：**
- ✅ 每次点击按钮都会实时检查
- ✅ 显示最新的只读状态

## 📊 日志对比

### 场景：锁定状态下点击备注按钮

**完整日志流程：**

```
1️⃣ 工具栏触发（第一次检查）
[ToolbarHijacker] 🎯 ========== 工具栏 showContent 被触发 ==========
[ReadonlyChecker] 🔐 检查系统只读模式...
[ReadonlyChecker] ✏️ 系统为可写模式
[ReadonlyChecker] 🎯 从选区查找文档只读状态...
[ReadonlyChecker] 🔒 文档为只读模式（锁已锁定）
[ToolbarHijacker] 📊 只读状态汇总: {
  系统级只读: 否✏️,
  文档级只读: 是🔒（锁已锁定）,
  最终判断: 只读模式
}

2️⃣ 点击备注按钮（实时检查） ← 新增！
[ToolbarHijacker] 💬 ========== 显示备注弹窗 ==========
[ReadonlyChecker] 🔐 检查系统只读模式...
[ReadonlyChecker] ✏️ 系统为可写模式

3️⃣ 真正显示弹窗前（实时检查） ← 关键！
[ToolbarHijacker] 🎨 ========== 准备显示备注输入弹窗 ==========
[ToolbarHijacker] 📋 当前文档只读状态 (实时检查): {
  custom-sy-readonly: "true",
  是否只读: "是🔒（锁已锁定）",
  查找方式: "从当前文档",
  弹窗状态: "即将显示"
}
```

## 🔧 技术细节

### 查找元素的优先级

#### `showEnhancedMemoInput` 中
1. **优先**: 从当前 `window.getSelection()` 的选区查找
2. **次选**: `.protyle-wysiwyg.protyle-wysiwyg--attr`
3. **兜底**: 遍历所有可见的 `.protyle-wysiwyg`

#### `applyHighlight` 中
1. **优先**: 从传入的 `range` 参数查找（最准确）
2. **兜底**: `.protyle-wysiwyg.protyle-wysiwyg--attr`

### 为什么需要多重查找？

- 📌 不同场景下元素的类名可能不同
- 📌 可能有多个编辑器同时打开
- 📌 第一次加载时某些元素可能还没初始化
- 📌 需要找到**当前活动**的编辑器

## ✅ 修复验证

现在你可以验证：

1. ✅ **第一次打开文档** - 实时检查会找到正确的元素
2. ✅ **切换锁状态** - 每次操作都重新检查
3. ✅ **多个文档** - 找到当前活动的文档
4. ✅ **日志清晰** - 能看到每次检查的结果

## 🎯 解决了什么问题？

| 问题 | 之前 | 现在 |
|------|------|------|
| **首次检查时机** | 工具栏触发时 | **真正显示弹窗前** |
| **检查次数** | 只检查一次 | **每次操作都检查** |
| **元素查找** | 单一选择器 | **多重查找策略** |
| **日志标识** | 无法区分 | **带"实时检查"标记** |

## 📦 构建信息

```bash
npm run build
```

- 构建成功 ✅
- 文件大小: 48.40 kB (之前 46.66 kB)
- gzip: 13.24 kB

## 🚀 下一步

1. **重启思源笔记**
2. **打开控制台看日志**
3. **试试点击锁图标切换状态**
4. **每次切换后点击备注或高亮按钮**
5. **观察 "(实时检查)" 的日志**
6. **验证是否准确显示了锁的状态**

---

**关键改进**: 从"检查一次"变成"每次操作前都实时检查" ✨

